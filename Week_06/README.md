# WEEK 6: 递归和动态规划

## 适用递归和动态规划的问题

递归和动态规划能解决的问题都有一个特性：原问题（problem）可以分解成若干个子问题（sub-problem），只有先解决了子问题才能进一步解决原问题。子问题的解决方式形式上与原问题一致。

从题目描述来看，可以提示我们尝试用递归、DP 解决的关键词有：compute n th element (value, sum, max, etc.)（求第 n 个元素、值、和、最大值等等），return all the paths（返回所有的路径），return all the combinations（返回所有的组合），return all the solutions（返回所有的解）...

## 递归和动态规划的不同

递归和动态规划最大的区别在于，DP 存储子问题的结果，当子问题已经被计算过，直接返回结果。因此，当需要重复计算子问题时，DP 的时间效率高很多，但需要额外的空间。

特别地，具有聚合属性的问题（Aggregate），例如在所有组合中寻找符合特定条件的特解（如二叉树求一条从根节点到叶节点和为定值的路径，或第 n 个元素 ），或最优解（包括最值），或总和，或数量的问题（其实看一下 SQL 里的聚合函数（Aggregate Function）就明白了）。因为这些问题只需要一个聚合的或者特殊的结果，而不是所有满足条件的集合，所以它们具有很强的收敛性质。这类问题往往也可以用 DP 来解决。

## 分治、动规、贪心、回溯

### 1. 分而治之（Divide and Conquer）

这里只谈狭义的 D&C，即将问题分成几个部分，每一部分相互独立，互不重叠，假定每个部分都可以得到解决来进行 递归调用，合并每一部分的结果。例如 Merge Sort Quick Sort（Merge Sort 的 divide 容易 ，但 Conquer/Merge 复杂 ，Quick Sort 的 divide 复杂 ，但 Conquer/Merge 容易）。

### 2. 动态规划（Dynamic Programming）

尽可能不重复计算每个子问题，而是将计算结果存储下来，以确定后驱问题的解。与贪婪算法的区别是，会记录下所有可能通向全局最优解的局部解，以便在计算后驱问题时综合考虑多个前驱问题的解。

### 3. 贪婪算法（Greedy Algorithm）

只做出当下最优的判断，并且以此为基础进行下一步计算。当前判断最优时，不考虑对全局/未来的影响，所以从全局来说并不能保证总是最优。贪婪算法每次更新当前的最优解。如 Dijkstra 算法就是贪婪算法的实例之一。

### 4. 回溯（Backtracking）

一种暴力（穷举）的深度优先搜索法：搜索，直到节点空间的尽头，然后再返回到上次的节点，再往其他方向深度搜索。树或图的 DFS 是回溯的实例之一。

## 利用动态规划解决的问题

### 一个模型

- **多阶段决策最优解模型**：我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

### 三个特征

1. **最优子结构**：最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

2. **无后效性**：无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

3. **重复子问题**：这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。
